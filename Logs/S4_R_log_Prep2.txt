
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> 
> #' ---
> #' title: "Library fragment alignment"
> #' author: "Tomas Bjorklund"
> #' edited by: "Jaro Steindorff"
> #' output: multipleContfragmentsComplete.rda -- a table holding |BC|tCount|Mode|mCount|mismatches|bitScore|LUTnr|Structure
> #'         This workflow identifies correct fragments from the Cre-recombined AAV plasmid library and aligns them to the CustumArray ordered nucleotide fragments using Blastn.
> #'         Consistant mutations in each fragment/barcode combination are also registered as is the putity of each barcode.
> #' ---
> 
> 
> suppressPackageStartupMessages(library(knitr)) 
> 
> #  This will make R-functions such as library() and install.packages() use this directory:
> .libPaths(c('~/MyRextensions', .libPaths()))
> 
> suppressPackageStartupMessages(library(ShortRead))
> suppressPackageStartupMessages(library(parallel))
> suppressPackageStartupMessages(library(doParallel))
> suppressPackageStartupMessages(library(data.table))
> suppressPackageStartupMessages(library(BSgenome))
> suppressPackageStartupMessages(library(GenomicFeatures))
> suppressPackageStartupMessages(library(GenomicAlignments))
> suppressPackageStartupMessages(library(GenomicRanges))
> suppressPackageStartupMessages(library(biovizBase))
> suppressPackageStartupMessages(library(Gviz))
> suppressPackageStartupMessages(library(plyr))
> suppressPackageStartupMessages(library(devtools))
> suppressPackageStartupMessages(library(Hmisc))
> suppressPackageStartupMessages(library(matrixStats))
> suppressPackageStartupMessages(library(stringdist))
> suppressPackageStartupMessages(library(scales))
> suppressPackageStartupMessages(library(kableExtra))
> 
> strt1<-Sys.time()
> 
> #' Load the trimmed reads
> #' ============================
> 
> # loading the LUT and the fragments
> load("0_data/LUTdna.rda")
> 
> # please select the barcode and fragment files that you want to analyze (Prep1 or Prep2)
> filename <- "Prep2"
> 
> # change the filename to the correct path
> path <- paste0("0_data/barcode_fragment/",filename,"_DNA_pscAAVlib/")
> 
> # loading the fragments and the barcodes 
> fragments.file <- paste0(path,"fragments_AAVlibrary_complete.fastq.gz")
> barcodes.file <- paste0(path,"barcodes_AAVlibrary_complete.fastq.gz")
> 
> # read the fragments and the barcodes into fastq files
> reads.trim <- readFastq(fragments.file)
> reads.BC <- readFastq(barcodes.file)
> 
> 
> #' Make CustomArray reference index for Blast
> #' ============================
> #+ Making Bowtie index.......
> 
> # convert the seq form the LUT to a fasta file for downstream analysis
> LUT.fa <- tempfile(pattern = "LUT_", tmpdir = tempdir(), fileext = ".fa")
> LUT.seq = ShortRead(DNAStringSet(LUT.dna$Sequence), BStringSet(1:length(LUT.dna$LUTnr)))
> writeFasta(LUT.seq,LUT.fa)
> 
> 
> #'Save unique fragments as fasta file
> #'===================
> unique.reads <- unique(sread(reads.trim))
> # converting the fragments to a fasta file for downstream analysis
> unique.reads <- ShortRead(DNAStringSet(unique.reads), BStringSet(1:length(unique.reads)))
> fragments.unique.fa <- tempfile(pattern = "FragUnique_", tmpdir = tempdir(), fileext = ".fa")
> writeFasta(unique.reads,fragments.unique.fa)
> 
> 
> #'Align against the library using blast
> #'===================
> # create a temporary file for the blast database and the output
> blast.db <- tempfile(pattern = "blastDB_", tmpdir = tempdir(), fileext = ".db")
> blast.out <- tempfile(pattern = "blastOut_", tmpdir = tempdir(), fileext = ".txt")
> 
> # create the blast database using the LUT sequnces
> sys.out <-  system(paste("makeblastdb -in ", LUT.fa,
+                          " -out ",blast.db," -dbtype nucl -title LUT -parse_seqids 2>&1",  sep = ""),
+                    intern = TRUE, ignore.stdout = FALSE) 
> 
> # print the size of the database
> system(paste("blastdbcmd -db ", blast.db, " -info", sep=" "))
Database: LUT
	92,343 sequences; 5,391,090 total bases

Date: Sep 17, 2024  9:59 AM	Longest sequence: 70 bases

BLASTDB Version: 5

Volumes:
	/local/slurmtmp.889981/RtmpxcaIkv/blastDB_28726853c4b946.db
> # print the number of unique fragments
> system(paste("grep -c '>' ", fragments.unique.fa, sep=" "))
4994
> 
> 
> # blastn the fragments against the LUT sequences
> # Determine the number of cores available
> num_threads <- detectCores()
> 
> # Construct the blastn command
> command <- paste0(
+   "blastn -max_target_seqs 25 -word_size 7",
+   " -num_threads ", num_threads,
+   " -outfmt 10 -db ", shQuote(blast.db),
+   " -query ", shQuote(fragments.unique.fa),
+   " > ", shQuote(blast.out), " 2>&1"
+ )
> # run the blastn look for all fragments in the db created by the sequneces in the LUT
> sys.out <- system(command, intern = TRUE, ignore.stdout = FALSE)
> 
> # write the output to a file
> system(paste("gzip -c ", blast.out, " > ./0_data/", filename, "_blastOutput.csv.gz", sep=""))
> 
> # create a data.table from the blast output
> table.blastn <- data.table(scan(file=paste("./0_data/", filename, "_blastOutput.csv.gz", sep=""), what="character", sep=";") , keep.rownames=FALSE, key="V1")
Read 115600 items
> 
> # if there are warnings in the blast output, remove them and store them in a separate data.table
> if (length(grep("Warning",table.blastn$V1)) != 0) {
+   warnings.out <- unique(table.blastn[grep("Warning",table.blastn$V1),])
+   table.blastn <- table.blastn[-grep("Warning",table.blastn$V1),]
+   setnames(warnings.out,"V1", c("blastn Warnings"))
+ }
> 
> # rename the columns
> table.blastn[,c("Reads","Sequence","identity","alignmentLength","mismatches",
+                 "gapOpens", "q_start", "q_end", "s_start", "s_end", 
+                 "evalue","bitScore") := tstrsplit(V1,",",fixed=TRUE),]
> 
> # replacing the numeric values with the actual sequence data from unique.reads and LUT.seq
> table.blastn[,Reads:= as.character(sread(unique.reads[as.integer(Reads)]))]
> table.blastn[,Sequence:= as.character(sread(LUT.seq[as.integer(Sequence)]))]
> 
> 
> #'Create full table of all fragments that mached the LUT with their blastn results
> #'===================
> # set the key to the sequence in both tables
> setkey(table.blastn,Sequence)
> setkey(LUT.dna,Sequence)
> 
> # keep only the rows that have a match in the LUT
> table.blastn<- table.blastn[LUT.dna, nomatch=0]
> # remove the sequence column
> table.blastn[,c("V1","identity","alignmentLength","gapOpens", "q_start", 
+                 "q_end", "s_start", "s_end", "evalue","Sequence","Names"):=NULL]
> 
> # change the data types of the columns
> table.blastn[,bitScore:= as.numeric(bitScore)]
> table.blastn[,mismatches:= as.numeric(mismatches)]
> 
> # set the key to the reads and the LUTnr
> setkeyv(table.blastn,c("Reads","LUTnr"))
> # make sure that the fragments are only aligned once to the reference in the top ten matches
> setorder(table.blastn,Reads,LUTnr,-bitScore)
> # have only unique pairs of reads and LUTnr
> table.blastn <- unique(table.blastn, by=c("Reads","LUTnr"))
> 
> # create a full table with the fragments and the barcodes
> full.table <- data.table(Reads=as.character(sread(reads.trim)),
+                          BC=as.character(sread(reads.BC)),
+                          key="Reads")
> 
> # selecting only the top hit for each read so we now have only one read for each LUTnr
> table.blastn.topHit <- table.blastn[table.blastn[, .I[which.max(bitScore)], by="Reads"]$V1]
> # merge the full table with the top hit table so we have only the best hit reads
> full.table <- full.table[table.blastn.topHit,nomatch=0]
> 
> # get the number of rows in the full table corresponding to the number of reads with barcodes
> all.reads <- nrow(full.table)
> 
> # calculate the percentage of reads that have been aligned to our db 
> print(paste("Alignment percentage:", percent(nrow(full.table)/all.reads)))
[1] "Alignment percentage: 100%"
> 
> 
> #' Starcode based barcode reduction
> #' ============================
> # create a temporary file for the output
> out.name.BC.star <- tempfile(pattern = "BCsc_", tmpdir = tempdir(), fileext = ".txt")
> # create the command for the starcode that clusters barcodes which are only one mismatch away from each other together
> command.args <- paste("-c ",barcodes.file," | starcode -t ",detectCores()-1," --print-clusters -d",
+                       1," -r5 -q -o ", out.name.BC.star, sep = "")
> # run starcode 
> system2("gunzip", args=command.args, stdout=TRUE, stderr=TRUE)
character(0)
> # read the output from starcode into a data.table
> table.BC.sc <- data.table(read.table(out.name.BC.star, header = FALSE, row.names = 1, skip = 0, sep="\t",
+                                      stringsAsFactors = FALSE, fill=FALSE),keep.rownames=TRUE, key="rn")
> # delete the V2 column
> table.BC.sc[,V2 := NULL]
> # split the V3 column into separate columns
> table.BC.sc <- table.BC.sc[, strsplit(as.character(V3),",",fixed=TRUE), by=rn]
> # calculate the number of barcodes that have been dropped
> SC.droppedBC <- length(unique(sread(reads.BC))) - length(unique(table.BC.sc$V1))
> print(paste("Dropped BCs in Starcode:", SC.droppedBC))
[1] "Dropped BCs in Starcode: 0"
> # rename the columns in the table to BC and scBC so we have the barcode and its corresponding starcode reduced barcode
> setnames(table.BC.sc,c("V1","rn"),c("BC","scBC"))
> # save the table of barcodes and their starcode reduced versions
> DNA_pscAAVlib <- table.BC.sc
> save(DNA_pscAAVlib, file="0_data/scBC_DNA_pscAAVlib.rda")
> 
> 
> #' Replacing barcodes with Starcode reduced versions
> #' ============================
> # set the keys in both tables
> setkey(full.table,BC)
> setkey(table.BC.sc,BC)
> # merge the full table with the starcode reduced table based on their BC
> full.table <- full.table[table.BC.sc,nomatch=0]
> 
> # change the names of the columns
> setnames(full.table,c("BC","scBC"),c("oldBC","BC"))
> # change the key to the new barcode
> setkey(full.table,BC)
> 
> # calculate the number of original barcodes and the number of unique barcodes after the reduction
> RetainedBC <- length(unique(full.table$oldBC))
> scBC <- length(unique(full.table$BC))
> print(paste("Original unique barcodes:", RetainedBC))
[1] "Original unique barcodes: 100211"
> print(paste("SC reduced unique barcodes:", scBC))
[1] "SC reduced unique barcodes: 94085"
> 
> # remove the old barcode column
> invisible(full.table[,oldBC:=NULL])
> 
> 
> #' Splitting reads into single-read and multi-read barcodes
> #' ============================
> # order the full table by the barcode and change the mismatches to numeric
> full.table <- full.table[order(full.table$BC),]
> full.table[,mismatches:= as.numeric(mismatches)]
> 
> # split the full table into single and multi-read barcodes
> temp.table.single <- full.table[full.table[, .I[.N == 1], by="BC"]$V1]
> temp.table.multi <- full.table[full.table[, .I[.N > 1], by="BC"]$V1]
> 
> # printig the number of reads we have and the number of single reads
> print("Utilized reads.......")
[1] "Utilized reads......."
> print(nrow(full.table))
[1] 247707
> print("Whereof single reads.......")
[1] "Whereof single reads......."
> print(nrow(temp.table.single))
[1] 62547
> 
> # set mcount and tcount to 1 for the single-read table
> temp.table.single[,c("mCount","tCount"):=1]
> # set the mode to Amb for ambiguous
> temp.table.single$Mode <- "Amb"
> 
> # setting a key vector for the multi-read table
> setkeyv(temp.table.multi,c("BC","LUTnr"))
> # set the name of the mode to Def for definitive
> temp.table.multi$Mode <- "Def"
> 
> # add three new columns to the multi-read table the mean bitScore, median mismatches and the total number of reads based on pairs of the same BC and LUTnr
> temp.table.multi[,c("bitScore","mismatches" ,"tCount"):= list(mean(bitScore),
+                                                               median(mismatches), .N), 
+                  by=key(temp.table.multi)]
> # tcount is the number of reads for each pair of barcode and LUTnr
> 
> # remove duplicates since we now have the tcount and the average bitScore and median mismatches we now have only uqniue combination of BC and LUTnr
> temp.table.multi <- unique(temp.table.multi)
> # now we only have unique pairs of BC and LUTnr in the multi-read table
> 
> 
> #' Splitting multi-read barcodes into clean and chimeric
> #' ============================
> #+ Splitting Clean Reads.......
> 
> # set the key to the barcode
> setkeyv(temp.table.multi,"BC")
> 
> # split the multi-read barcodes into once that have only one LUTnr and those that have more than one LUTnr
> temp.table.multi.clean <- temp.table.multi[temp.table.multi[, .I[.N == 1], by="BC"]$V1] # clean since 1 to 1 relation between BC and LUTnr
> temp.table.multi <- temp.table.multi[temp.table.multi[, .I[.N > 1], by="BC"]$V1] # chimeric since 1 to many relation between BC and LUTnr
> 
> # set the mCount to the tCount in barcodes with only one LUTnr so mCount= number of reads for this pair of BC and LUTnr
> temp.table.multi.clean[,mCount:=tCount]
> 
> # print the number of clean and chimeric multi-read barcodes
> print("Clean multi-read barcodes.......")
[1] "Clean multi-read barcodes......."
> print(nrow(temp.table.multi.clean))
[1] 21360
> print("Chimeric multi-read barcodes.......")
[1] "Chimeric multi-read barcodes......."
> print(length(unique(temp.table.multi$BC)))
[1] 10178
> 
> 
> #' Calculate consensus alignment of chimeric barcodes
> #' ============================
> # set the key to the barcode
> setkey(temp.table.multi,"BC")
> # set the mCount to the number of reads for each pair of BC and LUTnr
> temp.table.multi[, mCount:=tCount]
> 
> # now set the tCount to the sum of the tCounts of all entries with the same barcode (not considering the LUTnr) (tCount is the total number of reads for each barcode)
> temp.table.multi[, "tCount":=sum(tCount), by="BC"]
> 
> # delete the columns that are not needed
> temp.table.multi[,c("LUTnr","bitScore","mismatches","Structure"):=NULL]
> 
> # set the key to the Reads
> setkey(temp.table.multi,"Reads")
> # set the key of table.blastn to the Reads
> setkey(table.blastn,"Reads")
> 
> # join the table.blastn with the temp.table.multi based on the Reads. We allow for multiple matches and only keep the ones that have a match in both tables
> temp.table.multi <- temp.table.multi[table.blastn, nomatch=0, allow.cartesian=TRUE]
> 
> # set the key to a vector of the barcode and the LUTnr
> setkeyv(temp.table.multi,c("BC","LUTnr"))
> 
> # change the columns so we get the max bitScore, median mismatches and the sum of the mCounts for each pair of BC and LUTnr
> temp.table.multi[,c("bitScore","mismatches" ,"mCount"):= list(max(bitScore),
+                                                               median(mismatches), 
+                                                               sum(mCount)), by=key(temp.table.multi)]
> # mCount is the number of reads for each pair of barcode and LUTnr if we not only take the best hit from blast for each read
> 
> # delete duplicates so we now only have unique combination of BC and LUTnr with the highest bitScore
> temp.table.multi <- unique(temp.table.multi, by=c("BC","LUTnr"))
> 
> # set the key to the barcode
> setkeyv(temp.table.multi,"BC")
> # Select only BC LUTnr pairs with the maximum mCount for which means the maximum number of reads that would be possible for this barcode
> temp.table.multi <- temp.table.multi[temp.table.multi[, .I[mCount == max(mCount)], 
+                                                       by=key(temp.table.multi)]$V1] 
> # If there are multiple BC LUTnr pairs having the same number of reads we chose the barcode LUTnr pait with the highest bitScore from the blastn search
> temp.table.multi <- temp.table.multi[temp.table.multi[, .I[which.max(bitScore)], 
+                                                       by=key(temp.table.multi)]$V1] 
> 
> # if the barcode LUTnr combination has the highst bitScore and only has one mCount then it is a clean barcode
> temp.table.multi[temp.table.multi$mCount==1]$Mode <- "Amb"
> 
> # create a combined table with the clean cimeric and clean barcodes
> temp.table.multi.consensus <- rbind(temp.table.multi, temp.table.multi.clean)
> 
> print(paste("Total number of definitive Barcodes:", 
+             length(grep("Def", temp.table.multi.consensus$Mode))))
[1] "Total number of definitive Barcodes: 31494"
> print(paste("Total number of ambiguous Barcodes:", 
+             length(grep("Amb", temp.table.multi.consensus$Mode))))
[1] "Total number of ambiguous Barcodes: 44"
> print(paste("Total number of single-read Barcodes:", 
+             nrow(temp.table.single)))
[1] "Total number of single-read Barcodes: 62547"
> 
> # create the final output table with the single and multi-read barcodes
> output.Table <- rbind(temp.table.multi.consensus,temp.table.single)
> save(output.Table, file="0_data/multipleContfragmentsComplete.rda")
> 
> print("Total analysis time:")
[1] "Total analysis time:"
> print(Sys.time()-strt1)
Time difference of 19.09897 secs
> devtools::session_info()
─ Session info ───────────────────────────────────────────────────────────────
 setting  value
 version  R version 4.4.1 (2024-06-14)
 os       Rocky Linux 9.4 (Blue Onyx)
 system   x86_64, linux-gnu
 ui       X11
 language (EN)
 collate  en_US.UTF-8
 ctype    en_US.UTF-8
 tz       Europe/Stockholm
 date     2024-09-17
 pandoc   NA (via rmarkdown)

─ Packages ───────────────────────────────────────────────────────────────────
 ! package              * version   date (UTC) lib source
   abind                  1.4-5     2016-07-21 [1] CRAN (R 4.4.1)
   AnnotationDbi        * 1.66.0    2024-05-01 [1] Bioconductor 3.19 (R 4.4.1)
   AnnotationFilter       1.28.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   backports              1.5.0     2024-05-23 [1] CRAN (R 4.4.1)
   base64enc              0.1-3     2015-07-28 [2] CRAN (R 4.4.1)
   Biobase              * 2.64.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   BiocFileCache          2.12.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   BiocGenerics         * 0.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   BiocIO               * 1.14.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   BiocParallel         * 1.38.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   biomaRt                2.60.1    2024-06-26 [1] Bioconductor 3.19 (R 4.4.1)
   Biostrings           * 2.72.1    2024-06-02 [1] Bioconductor 3.19 (R 4.4.1)
   biovizBase           * 1.52.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   bit                    4.0.5     2022-11-15 [1] CRAN (R 4.4.1)
   bit64                  4.0.5     2020-08-30 [1] CRAN (R 4.4.1)
   bitops                 1.0-8     2024-07-29 [1] CRAN (R 4.4.1)
   blob                   1.2.4     2023-03-17 [1] CRAN (R 4.4.1)
   BSgenome             * 1.72.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   cachem                 1.1.0     2024-05-16 [2] CRAN (R 4.4.1)
   checkmate              2.3.2     2024-07-29 [1] CRAN (R 4.4.1)
   cli                    3.6.3     2024-06-21 [2] CRAN (R 4.4.1)
   cluster                2.1.6     2023-12-01 [1] CRAN (R 4.4.1)
   codetools              0.2-20    2024-03-31 [1] CRAN (R 4.4.1)
   colorspace             2.1-1     2024-07-26 [1] CRAN (R 4.4.1)
   crayon                 1.5.3     2024-06-20 [2] CRAN (R 4.4.1)
   curl                   5.2.2     2024-08-26 [1] CRAN (R 4.3.1)
   data.table           * 1.16.0    2024-08-27 [1] CRAN (R 4.4.1)
   DBI                    1.2.3     2024-06-02 [1] CRAN (R 4.4.1)
   dbplyr                 2.5.0     2024-03-19 [1] CRAN (R 4.4.1)
   DelayedArray           0.30.1    2024-05-07 [1] Bioconductor 3.19 (R 4.4.1)
   deldir                 2.0-4     2024-02-28 [1] CRAN (R 4.4.1)
   devtools             * 2.4.5     2022-10-11 [1] CRAN (R 4.4.1)
   dichromat              2.0-0.1   2022-05-02 [1] CRAN (R 4.4.1)
   digest                 0.6.37    2024-08-19 [2] CRAN (R 4.4.1)
   doParallel           * 1.0.17    2022-02-07 [1] CRAN (R 4.4.1)
   dplyr                  1.1.4     2023-11-17 [1] CRAN (R 4.4.1)
   ellipsis               0.3.2     2021-04-29 [2] CRAN (R 4.4.1)
   ensembldb              2.28.1    2024-08-21 [1] Bioconductor 3.19 (R 4.4.1)
   evaluate               0.24.0    2024-06-10 [1] CRAN (R 4.3.1)
   fansi                  1.0.6     2023-12-08 [2] CRAN (R 4.4.1)
   fastmap                1.2.0     2024-05-15 [2] CRAN (R 4.4.1)
   filelock               1.0.3     2023-12-11 [1] CRAN (R 4.4.1)
   foreach              * 1.5.2     2022-02-02 [1] CRAN (R 4.4.1)
   foreign                0.8-87    2024-06-26 [1] CRAN (R 4.4.1)
   Formula                1.2-5     2023-02-24 [1] CRAN (R 4.4.1)
   fs                     1.6.4     2024-04-25 [2] CRAN (R 4.4.1)
   generics               0.1.3     2022-07-05 [1] CRAN (R 4.4.1)
   GenomeInfoDb         * 1.40.1    2024-05-24 [1] Bioconductor 3.19 (R 4.4.1)
   GenomeInfoDbData       1.2.12    2024-09-05 [1] Bioconductor
   GenomicAlignments    * 1.40.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   GenomicFeatures      * 1.56.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   GenomicRanges        * 1.56.1    2024-06-12 [1] Bioconductor 3.19 (R 4.4.1)
   ggplot2                3.5.1     2024-04-23 [1] CRAN (R 4.4.1)
   glue                   1.7.0     2024-01-09 [2] CRAN (R 4.4.1)
   gridExtra              2.3       2017-09-09 [1] CRAN (R 4.4.1)
   gtable                 0.3.5     2024-04-22 [1] CRAN (R 4.4.1)
   Gviz                 * 1.48.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   Hmisc                * 5.1-3     2024-05-28 [1] CRAN (R 4.4.1)
   hms                    1.1.3     2023-03-21 [1] CRAN (R 4.4.1)
   htmlTable              2.4.3     2024-07-21 [1] CRAN (R 4.4.1)
   htmltools              0.5.8.1   2024-04-04 [2] CRAN (R 4.4.1)
   htmlwidgets            1.6.4     2023-12-06 [2] CRAN (R 4.4.1)
   httpuv                 1.6.15    2024-03-26 [2] CRAN (R 4.4.1)
   httr                   1.4.7     2023-08-15 [1] CRAN (R 4.3.1)
   httr2                  1.0.4     2024-09-13 [2] CRAN (R 4.4.1)
   hwriter                1.3.2.1   2022-04-08 [1] CRAN (R 4.4.1)
   interp                 1.1-6     2024-01-26 [1] CRAN (R 4.4.1)
   IRanges              * 2.38.1    2024-07-03 [1] Bioconductor 3.19 (R 4.4.1)
   iterators            * 1.0.14    2022-02-05 [1] CRAN (R 4.4.1)
   jpeg                   0.1-10    2022-11-29 [1] CRAN (R 4.4.1)
   jsonlite               1.8.8     2023-12-04 [1] CRAN (R 4.3.1)
   kableExtra           * 1.4.0     2024-01-24 [1] CRAN (R 4.4.1)
   KEGGREST               1.44.1    2024-06-19 [1] Bioconductor 3.19 (R 4.4.1)
 P knitr                * 1.48      2024-07-07 [2] CRAN (R 4.3.1)
   later                  1.3.2     2023-12-06 [2] CRAN (R 4.4.1)
   lattice                0.22-6    2024-03-20 [1] CRAN (R 4.4.1)
   latticeExtra           0.6-30    2022-07-04 [1] CRAN (R 4.4.1)
   lazyeval               0.2.2     2019-03-15 [1] CRAN (R 4.4.1)
   lifecycle              1.0.4     2023-11-07 [2] CRAN (R 4.4.1)
   magrittr               2.0.3     2022-03-30 [2] CRAN (R 4.4.1)
   Matrix                 1.7-0     2024-04-26 [1] CRAN (R 4.4.1)
   MatrixGenerics       * 1.16.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   matrixStats          * 1.4.1     2024-09-08 [1] CRAN (R 4.4.1)
   memoise                2.0.1     2021-11-26 [2] CRAN (R 4.4.1)
   mime                   0.12      2021-09-28 [1] CRAN (R 4.3.1)
   miniUI                 0.1.1.1   2018-05-18 [2] CRAN (R 4.4.1)
   munsell                0.5.1     2024-04-01 [1] CRAN (R 4.4.1)
   nnet                   7.3-19    2023-05-03 [1] CRAN (R 4.4.1)
   pillar                 1.9.0     2023-03-22 [2] CRAN (R 4.4.1)
   pkgbuild               1.4.4     2024-03-17 [2] CRAN (R 4.4.1)
   pkgconfig              2.0.3     2019-09-22 [2] CRAN (R 4.4.1)
   pkgload                1.4.0     2024-06-28 [2] CRAN (R 4.4.1)
   plyr                 * 1.8.9     2023-10-02 [1] CRAN (R 4.4.1)
   png                    0.1-8     2022-11-29 [1] CRAN (R 4.4.1)
   prettyunits            1.2.0     2023-09-24 [2] CRAN (R 4.4.1)
   profvis                0.3.8     2023-05-02 [2] CRAN (R 4.4.1)
   progress               1.2.3     2023-12-06 [1] CRAN (R 4.4.1)
   promises               1.3.0     2024-04-05 [2] CRAN (R 4.4.1)
   ProtGenerics           1.36.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   purrr                  1.0.2     2023-08-10 [2] CRAN (R 4.4.1)
   pwalign                1.0.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   R6                     2.5.1     2021-08-19 [1] CRAN (R 4.3.1)
   rappdirs               0.3.3     2021-01-31 [2] CRAN (R 4.4.1)
   RColorBrewer           1.1-3     2022-04-03 [1] CRAN (R 4.4.1)
   Rcpp                   1.0.13    2024-07-17 [2] CRAN (R 4.4.1)
   RCurl                  1.98-1.16 2024-07-11 [1] CRAN (R 4.4.1)
   remotes                2.5.0     2024-03-17 [2] CRAN (R 4.4.1)
   restfulr               0.0.15    2022-06-16 [1] CRAN (R 4.4.1)
   rjson                  0.2.22    2024-08-20 [1] CRAN (R 4.4.1)
   rlang                  1.1.4     2024-06-04 [2] CRAN (R 4.4.1)
   rmarkdown              2.28      2024-08-17 [2] CRAN (R 4.4.1)
   rpart                  4.1.23    2023-12-05 [1] CRAN (R 4.4.1)
   Rsamtools            * 2.20.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   RSQLite                2.3.7     2024-05-27 [1] CRAN (R 4.4.1)
   rstudioapi             0.16.0    2024-03-24 [2] CRAN (R 4.4.1)
   rtracklayer          * 1.64.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   S4Arrays               1.4.1     2024-05-20 [1] Bioconductor 3.19 (R 4.4.1)
   S4Vectors            * 0.42.1    2024-07-03 [1] Bioconductor 3.19 (R 4.4.1)
   scales               * 1.3.0     2023-11-28 [1] CRAN (R 4.4.1)
   sessioninfo            1.2.2     2021-12-06 [2] CRAN (R 4.4.1)
   shiny                  1.9.1     2024-08-01 [2] CRAN (R 4.4.1)
   ShortRead            * 1.62.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   SparseArray            1.4.8     2024-05-24 [1] Bioconductor 3.19 (R 4.4.1)
   stringdist           * 0.9.12    2023-11-28 [1] CRAN (R 4.4.1)
   stringi                1.8.4     2024-05-06 [2] CRAN (R 4.4.1)
   stringr                1.5.1     2023-11-14 [2] CRAN (R 4.4.1)
   SummarizedExperiment * 1.34.0    2024-05-01 [1] Bioconductor 3.19 (R 4.4.1)
   svglite                2.1.3     2023-12-08 [1] CRAN (R 4.4.1)
   systemfonts            1.1.0     2024-05-15 [2] CRAN (R 4.4.1)
   tibble                 3.2.1     2023-03-20 [2] CRAN (R 4.4.1)
   tidyselect             1.2.1     2024-03-11 [1] CRAN (R 4.4.1)
   UCSC.utils             1.0.0     2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   urlchecker             1.0.1     2021-11-30 [2] CRAN (R 4.4.1)
   usethis              * 3.0.0     2024-07-29 [2] CRAN (R 4.4.1)
   utf8                   1.2.4     2023-10-22 [2] CRAN (R 4.4.1)
   VariantAnnotation      1.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   vctrs                  0.6.5     2023-12-01 [2] CRAN (R 4.4.1)
   viridisLite            0.4.2     2023-05-02 [1] CRAN (R 4.4.1)
 P xfun                   0.47      2024-08-17 [2] CRAN (R 4.3.1)
   XML                    3.99-0.17 2024-06-25 [1] CRAN (R 4.4.1)
   xml2                   1.3.6     2023-12-04 [2] CRAN (R 4.4.1)
   xtable                 1.8-4     2019-04-21 [2] CRAN (R 4.4.1)
   XVector              * 0.44.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)
   yaml                   2.3.10    2024-07-26 [1] CRAN (R 4.3.1)
   zlibbioc               1.50.0    2024-04-30 [1] Bioconductor 3.19 (R 4.4.1)

 [1] /home/jarost/MyRextensions
 [2] /sw/easybuild_milan/software/R/4.4.1-foss-2023a/lib64/R/library

 P ── Loaded and on-disk path mismatch.

──────────────────────────────────────────────────────────────────────────────
> 
> proc.time()
   user  system elapsed 
 99.308   5.956  34.347 
